/* ----------------------------------------------------------------------------------------
# 
# Git: https://github.com/franky527/8042-a2-exploit/blob/main/README.adoc  
# VulnerableProgram.exe was created to perform the following functions:
# 1) Read a text file
# 2) Copy a text file
# 3) Write the copied text file to a new name
#
# Further, VulnerableProgram.exe was created to demonstrate buffer flow vulnerabilities
# 	There is way to enter character in from the screen (intended to be the file name of the file to be copied). This has been hard coded to "original_file.txt" for testing purposes.
#	There is a way to read the file in with more characters than an array allows, allowing values to be overwriten in menory 
#	The corresponding Exploit1-VirtAll.py file will overwrite the "original_file.txt" with an exploit to establish a TCP shell on Port 443, to the attacking Kali machine on 198.168.100.5 
#
# Steps to compile VulnerableProgram:
#	1) Using Command Prompt, run the g++ -o VulnerableProgram.exe VulnerableProgram.cpp    
#     
#----------------------------------------------------------------------------------------
# */

//Libraries
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>

//declaring global variables
char FileName[20] = "original_file.txt";
char NewFileName[20] = "new_file.txt";

using namespace std;

//Function to print welcome message for program
void WelcomeMessage() {  
	cout << "---------------------------------------------------- \n" << endl;
	cout << "Welcome to the ZIET8042 Vulnerable Program \n" << endl;
	cout << "This is a program to read file contents, perform a copy and write the copy to a new file \n" << endl;
	cout << "The file will do this in 3 steps: " << endl;
	cout << "1) Read the file " << endl;
	cout << "2) Copy the file " << endl;
	cout << "3) Write the file contents \n" << endl;
	cout << "---------------------------------------------------- \n" << endl;
}

//Function to the file read, copy and write
void ReturnFunction() { 

	//WelcomeMessage();	 removed at some point, to assist with function buffer overflow analysis 
	
	//Function variables, with FileCopy set to a limit of 2000 characters  
	char FileCopy[2000];
	string FileText;
	
	//Capturing the name of file to copy as program input
	cout << "Enter Filename: ";	// Screen output requesting input
	//cin >> FileName;     		// Capturing screen input - commented out for testing
	puts(FileName);				// Was a way to confirm user input, but confirms the input file is "original_file.txt"

	//Read the file, open the file 
	ifstream ReadFile(FileName);
		
	while (getline (ReadFile, FileText)) {
		printf("STEP 1) Reading the original file: \t"); 
		cout << FileText << endl;
	}

	//close the file 
	ReadFile.close();

	//perform the vulerable copy into FileCopy, this is vulnerable to overflow with characters > 2000
	strcpy(FileCopy, FileText.c_str()); 

}    

void Function() {

	//Was an original way of checking buffer overflow in the program with basic screen input
	//Has become of no vlaue to program over time 
	char name [10];
	cin >> name;

}

int main() {

	Function();
	ReturnFunction();
	
    return 0;
	
}

/*
#---------------------------------------------------------------------------
# Lessons from recent C++ programming:
# 
# 1) It's essential understanding how the C++ functions are being allocated the memory space for processing:
# 	Maybe obvious with experience, but this learning has really validated the stack-based memory allocation and overwriting into return addressing
# 	The graphical visual aids with memory allocations were also invaluable to validate understanding of the text-based views of memory, and observing how values are stored in memory space 
#
# 2) It takes time to put the C++ instructions in context with the stack and register behaviour: 
#	The memory based tools have been insightful, but not always intuitive. 
#	Developing an application to demonstrate buffer vulnerabilities has been a further aspect; found to be challenging but definately rewarding learning as someone without a lot of experience at this technical level
#
# 3) The previous experiences of exploits on existing .exe programs was essential to understand buffer overflow behavious
#	Coding programs has definatelty reinforced the learning of buffer overflow, and what vulnerable code looks like
#	The repitition of undertaking different exploit development has taken time and deep focus, but the practice does reinforce the learning and techniques
#	
# */
